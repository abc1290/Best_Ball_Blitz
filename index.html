a.isPlus && b.isPlus) {
                return b.handicap - a.handicap;
              } else {
                return a.handicap - b.handicap;
              }
            });
            const quarterSize = Math.ceil(sortedPlayers.length / 4);
            _data.groups.A = sortedPlayers.slice(0, quarterSize);
            _data.groups.B = sortedPlayers.slice(quarterSize, quarterSize * 2);
            _data.groups.C = sortedPlayers.slice(quarterSize * 2, quarterSize * 3);
            _data.groups.D = sortedPlayers.slice(quarterSize * 3);
            return { success: true };
          },
          selectTeam: () => {
            const groups = _data.groups;
            if (groups.A.length === 0 || groups.B.length === 0 || groups.C.length === 0 || groups.D.length === 0) {
              return { success: false, message: "Not enough players left to form a full team." };
            }
            let playerA, playerB, playerC, playerD;
            if (_data.settings.balanceTeams && _data.teams.length > 0) {
              let totalHandicap = 0;
              _data.teams.forEach(team => { totalHandicap += calculateTeamHandicap(team); });
              const avgHandicap = totalHandicap / _data.teams.length;
              let bestTeam = null;
              let bestDifference = Infinity;
              const maxAttempts = 50;
              const maxDiff = parseFloat(_data.settings.maxHandicapDiff) || 0;
              for (let i = 0; i < maxAttempts; i++) {
                const testPlayerA = groups.A[Math.floor(Math.random() * groups.A.length)];
                const testPlayerB = groups.B[Math.floor(Math.random() * groups.B.length)];
                const testPlayerC = groups.C[Math.floor(Math.random() * groups.C.length)];
                const testPlayerD = groups.D[Math.floor(Math.random() * groups.D.length)];
                const testTeam = { members: [testPlayerA, testPlayerB, testPlayerC, testPlayerD] };
                const teamHandicap = calculateTeamHandicap(testTeam);
                const difference = Math.abs(teamHandicap - avgHandicap);
                if ((maxDiff > 0 && difference <= maxDiff) || difference < bestDifference) {
                  bestDifference = difference;
                  bestTeam = [testPlayerA, testPlayerB, testPlayerC, testPlayerD];
                  if (maxDiff > 0 && difference <= maxDiff) { break; }
                }
              }
              if (bestTeam) {
                playerA = bestTeam[0];
                playerB = bestTeam[1];
                playerC = bestTeam[2];
                playerD = bestTeam[3];
              }
            } else {
              playerA = groups.A[Math.floor(Math.random() * groups.A.length)];
              playerB = groups.B[Math.floor(Math.random() * groups.B.length)];
              playerC = groups.C[Math.floor(Math.random() * groups.C.length)];
              playerD = groups.D[Math.floor(Math.random() * groups.D.length)];
            }
            groups.A.splice(groups.A.indexOf(playerA), 1);
            groups.B.splice(groups.B.indexOf(playerB), 1);
            groups.C.splice(groups.C.indexOf(playerC), 1);
            groups.D.splice(groups.D.indexOf(playerD), 1);
            const team = {
              id: _data.teams.length + 1,
              members: [playerA, playerB, playerC, playerD]
            };
            team.totalHandicap = calculateTeamHandicap(team);
            _data.teams.push(team);
            return { success: true, team };
          },
          canFormTeam: () => {
            const groups = _data.groups;
            return groups.A.length > 0 && groups.B.length > 0 && groups.C.length > 0 && groups.D.length > 0;
          },
          findTeamById: (teamId) => _data.teams.find(team => team.id === teamId),
          assignTeamToHole: (teamId, hole) => {
            if (!_data.holeAssignments[hole]) { _data.holeAssignments[hole] = []; }
            const isDoubleStacked = doubleStackedHoles.includes(Number(hole));
            const maxTeams = isDoubleStacked ? 2 : 1;
            if (_data.holeAssignments[hole].length >= maxTeams) {
              return { success: false, message: `Hole ${hole} already has the maximum number of teams.` };
            }
            for (const h in _data.holeAssignments) {
              const index = _data.holeAssignments[h].indexOf(teamId);
              if (index !== -1) { _data.holeAssignments[h].splice(index, 1); }
            }
            _data.holeAssignments[hole].push(teamId);
            return { success: true };
          },
          removeTeamFromHole: (teamId, hole) => {
            if (!_data.holeAssignments[hole]) { return { success: false, message: "Hole does not exist." }; }
            const index = _data.holeAssignments[hole].indexOf(teamId);
            if (index !== -1) {
              _data.holeAssignments[hole].splice(index, 1);
              return { success: true };
            }
            return { success: false, message: "Team not assigned to this hole." };
          },
          getAssignedTeamIds: () => {
            const assignedTeams = [];
            for (const hole in _data.holeAssignments) { assignedTeams.push(..._data.holeAssignments[hole]); }
            return assignedTeams;
          },
          autoAssignTeams: () => {
            for (let i = 1; i <= 18; i++) { _data.holeAssignments[i] = []; }
            const teamsToAssign = [..._data.teams.map(team => team.id)];
            for (const hole of doubleStackedHoles) {
              for (let i = 0; i < 2; i++) {
                if (teamsToAssign.length > 0) {
                  const teamId = teamsToAssign.shift();
                  _data.holeAssignments[hole].push(teamId);
                }
              }
            }
            for (let hole = 1; hole <= 18; hole++) {
              if (!doubleStackedHoles.includes(hole)) {
                if (teamsToAssign.length > 0) {
                  const teamId = teamsToAssign.shift();
                  _data.holeAssignments[hole].push(teamId);
                }
              }
            }
            return { success: true };
          },
          randomizeTeamAssignments: () => {
            for (let i = 1; i <= 18; i++) { _data.holeAssignments[i] = []; }
            const teamsToAssign = [..._data.teams.map(team => team.id)];
            for (let i = teamsToAssign.length - 1; i > 0; i--) {
              const j = Math.floor(Math.random() * (i + 1));
              [teamsToAssign[i], teamsToAssign[j]] = [teamsToAssign[j], teamsToAssign[i]];
            }
            const availableHoles = [];
            doubleStackedHoles.forEach(hole => { availableHoles.push({ hole, capacity: 2 }); });
            for (let hole = 1; hole <= 18; hole++) {
              if (!doubleStackedHoles.includes(hole)) { availableHoles.push({ hole, capacity: 1 }); }
            }
            for (let i = availableHoles.length - 1; i > 0; i--) {
              const j = Math.floor(Math.random() * (i + 1));
              [availableHoles[i], availableHoles[j]] = [availableHoles[j], availableHoles[i]];
            }
            let holeIndex = 0;
            while (teamsToAssign.length > 0 && holeIndex < availableHoles.length) {
              const hole = availableHoles[holeIndex].hole;
              if (!_data.holeAssignments[hole]) { _data.holeAssignments[hole] = []; }
              if (_data.holeAssignments[hole].length < availableHoles[holeIndex].capacity) {
                const teamId = teamsToAssign.shift();
                _data.holeAssignments[hole].push(teamId);
              } else { holeIndex++; }
            }
            return { success: true };
          },
          processCSV: (csv) => {
            const lines = csv.split(/\r\n|\n/);
            const importedPlayers = [];
            const errors = [];
            for (let i = 0; i < lines.length; i++) {
              if (!lines[i].trim()) continue;
              const parts = lines[i].split(',');
              if (parts.length < 3) {
                errors.push(`Line ${i+1} doesn't have enough data. Format should be LastName,FirstName,Handicap`);
                continue;
              }
              const lastName = parts[0].trim();
              const firstName = parts[1].trim();
              const handicapInput = parts[2].trim();
              const handicapValidation = validateHandicap(handicapInput);
              if (!handicapValidation.valid) {
                errors.push(`Invalid handicap format in line ${i+1}: ${handicapValidation.message}`);
                continue;
              }
              const player = {
                name: `${lastName}, ${firstName}`,
                handicap: handicapValidation.value,
                isPlus: handicapValidation.isPlus,
                displayHandicap: handicapValidation.isPlus ? `+${handicapValidation.value}` : handicapValidation.value.toString()
              };
              importedPlayers.push(player);
            }
            return { players: importedPlayers, errors };
          },
          saveToLocalStorage: () => {
            try {
              const dataToSave = {
                players: _data.players,
                groups: _data.groups,
                teams: _data.teams,
                holeAssignments: _data.holeAssignments,
                settings: _data.settings
              };
              localStorage.setItem('golfApp', JSON.stringify(dataToSave));
              return { success: true };
            } catch (error) {
              return { success: false, message: `Failed to save data: ${error.message}` };
            }
          },
          loadFromLocalStorage: () => {
            try {
              const savedData = localStorage.getItem('golfApp');
              if (!savedData) { return { success: false, message: 'No saved data found' }; }
              const parsedData = JSON.parse(savedData);
              _data.players = parsedData.players || [];
              _data.groups = parsedData.groups || { A: [], B: [], C: [], D: [] };
              _data.teams = parsedData.teams || [];
              _data.holeAssignments = parsedData.holeAssignments || {};
              if (parsedData.settings) { _data.settings = parsedData.settings; }
              return { success: true };
            } catch (error) {
              return { success: false, message: `Failed to load data: ${error.message}` };
            }
          },
          calculateTeamHandicap: calculateTeamHandicap
        };
      })();
      
      /**
       * UI Controller Module
       * Manages the user interface and DOM interactions
       */
      GolfApp.UIController = (function() {
        const DOMElements = {
          tabButtons: document.querySelectorAll('.tab-button'),
          tabContents: document.querySelectorAll('.tab-content'),
          teeAssignmentTabButton: document.getElementById('teeAssignmentTabButton'),
          playerNameInput: document.getElementById('playerName'),
          playerHandicapInput: document.getElementById('playerHandicap'),
          addPlayerBtn: document.getElementById('addPlayerBtn'),
          resetBtn: document.getElementById('resetBtn'),
          playerList: document.getElementById('playerList'),
          playerCountElement: document.getElementById('playerCount'),
          nameValidation: document.getElementById('nameValidation'),
          handicapValidation: document.getElementById('handicapValidation'),
          balanceTeamsToggle: document.getElementById('balanceTeamsToggle'),
          maxHandicapDiff: document.getElementById('maxHandicapDiff'),
          groupPlayersBtn: document.getElementById('groupPlayersBtn'),
          groupA: document.getElementById('groupA'),
          groupB: document.getElementById('groupB'),
          groupC: document.getElementById('groupC'),
          groupD: document.getElementById('groupD'),
          selectTeamBtn: document.getElementById('selectTeamBtn'),
          selectAllBtn: document.getElementById('selectAllBtn'),
          sequentialSelectTeamBtn: document.getElementById('sequentialSelectTeamBtn'),
          randomTeamSelectBtn: document.getElementById('randomTeamSelectBtn'), // New button
          showBracketBtn: document.getElementById('showBracketBtn'),
          teamsContainer: document.getElementById('teamsContainer'),
          teamCountElement: document.getElementById('teamCount'),
          selectionSlots: {
            A: document.getElementById('slotA'),
            B: document.getElementById('slotB'),
            C: document.getElementById('slotC'),
            D: document.getElementById('slotD')
          },
          startFormatSelect: document.getElementById('startFormat'),
          startTimeInput: document.getElementById('startTime'),
          timeIntervalInput: document.getElementById('timeInterval'),
          courseLayout: document.getElementById('courseLayout'),
          unassignedTeamsList: document.getElementById('unassignedTeamsList'),
          autoAssignBtn: document.getElementById('autoAssignBtn'),
          randomAssignBtn: document.getElementById('randomAssignBtn'),
          resetAssignmentBtn: document.getElementById('resetAssignmentBtn'),
          teeSheetBody: document.getElementById('teeSheetBody'),
          printTeeSheetBtn: document.getElementById('printTeeSheetBtn'),
          errorMessages: document.getElementById('errorMessages'),
          fileInput: document.getElementById('fileInput'),
          helpButton: document.getElementById('helpButton'),
          saveButton: document.getElementById('saveButton'),
          loadButton: document.getElementById('loadButton'),
          tutorialOverlay: document.getElementById('tutorialOverlay'),
          tutorialSteps: document.querySelector('.tutorial-steps'),
          tutorialPrevBtn: document.getElementById('tutorialPrevBtn'),
          tutorialNextBtn: document.getElementById('tutorialNextBtn'),
          tutorialProgress: document.getElementById('tutorialProgress'),
          tutorialCloseBtn: document.querySelector('.tutorial-close')
        };
        
        const UIState = {
          isGrouped: false,
          selectedTeamId: null,
          currentTutorialStep: 0
        };
        
        // New function: Random Team Selection
        function randomTeamSelection() {
          const groups = GolfApp.DataModel.getGroups();
          
          // Check if there are enough players in each group
          if (groups.A.length === 0 || groups.B.length === 0 || 
              groups.C.length === 0 || groups.D.length === 0) {
            GolfApp.UIController.showError("Not enough players left to form a full team.");
            return { success: false, message: "Not enough players left to form a full team." };
          }
          
          // Create a simple overlay to display the results
          const overlay = document.createElement('div');
          overlay.className = 'selection-fullscreen';
          overlay.id = 'random-selection-overlay';
          
          const header = document.createElement('h2');
          header.textContent = 'Random Team Selection';
          overlay.appendChild(header);
          
          // Create a container for the selected players
          const teamContainer = document.createElement('div');
          teamContainer.style.width = '80%';
          teamContainer.style.margin = '20px auto';
          teamContainer.style.backgroundColor = 'rgba(255, 255, 255, 0.9)';
          teamContainer.style.padding = '20px';
          teamContainer.style.borderRadius = '8px';
          teamContainer.style.color = '#333';
          overlay.appendChild(teamContainer);
          
          // Add buttons
          const buttonsContainer = document.createElement('div');
          buttonsContainer.style.marginTop = '30px';
          
          const acceptButton = document.createElement('button');
          acceptButton.textContent = 'Accept Team';
          acceptButton.style.marginRight = '20px';
          
          const rerollButton = document.createElement('button');
          rerollButton.textContent = 'Reroll Team';
          
          buttonsContainer.appendChild(acceptButton);
          buttonsContainer.appendChild(rerollButton);
          overlay.appendChild(buttonsContainer);
          
          document.body.appendChild(overlay);
          
          // Function to randomly select players and display them
          function selectRandomPlayers() {
            // Select one random player from each group
            const playerA = groups.A[Math.floor(Math.random() * groups.A.length)];
            const playerB = groups.B[Math.floor(Math.random() * groups.B.length)];
            const playerC = groups.C[Math.floor(Math.random() * groups.C.length)];
            const playerD = groups.D[Math.floor(Math.random() * groups.D.length)];
            
            // Display the selected players
            teamContainer.innerHTML = `
              <h3>Randomly Selected Team</h3>
              <div class="team-member" style="padding: 10px; margin: 5px 0; background-color: #f0f0f0; border-radius: 5px;">
                <strong>Group A:</strong> ${playerA.name} (${playerA.displayHandicap})
              </div>
              <div class="team-member" style="padding: 10px; margin: 5px 0; background-color: #f0f0f0; border-radius: 5px;">
                <strong>Group B:</strong> ${playerB.name} (${playerB.displayHandicap})
              </div>
              <div class="team-member" style="padding: 10px; margin: 5px 0; background-color: #f0f0f0; border-radius: 5px;">
                <strong>Group C:</strong> ${playerC.name} (${playerC.displayHandicap})
              </div>
              <div class="team-member" style="padding: 10px; margin: 5px 0; background-color: #f0f0f0; border-radius: 5px;">
                <strong>Group D:</strong> ${playerD.name} (${playerD.displayHandicap})
              </div>
            `;
            
            // Calculate and display team handicap
            const teamHandicap = GolfApp.DataModel.calculateTeamHandicap({
              members: [playerA, playerB, playerC, playerD]
            });
            const displayHandicap = teamHandicap.toFixed(1);
            const displaySign = teamHandicap < 0 ? '+' : '';
            
            const handicapDiv = document.createElement('div');
            handicapDiv.style.marginTop = '15px';
            handicapDiv.style.fontWeight = 'bold';
            handicapDiv.innerHTML = `Team Handicap: ${displaySign}${Math.abs(displayHandicap)}`;
            teamContainer.appendChild(handicapDiv);
            
            return { playerA, playerB, playerC, playerD };
          }
          
          // Initial selection
          let selectedPlayers = selectRandomPlayers();
          
          // Set up button events
          rerollButton.addEventListener('click', () => {
            // Reselect random players
            selectedPlayers = selectRandomPlayers();
          });
          
          acceptButton.addEventListener('click', () => {
            // Remove selected players from their groups
            groups.A.splice(groups.A.indexOf(selectedPlayers.playerA), 1);
            groups.B.splice(groups.B.indexOf(selectedPlayers.playerB), 1);
            groups.C.splice(groups.C.indexOf(selectedPlayers.playerC), 1);
            groups.D.splice(groups.D.indexOf(selectedPlayers.playerD), 1);
            
            // Create and add the team
            const team = {
              id: GolfApp.DataModel.getTeams().length + 1,
              members: [selectedPlayers.playerA, selectedPlayers.playerB, selectedPlayers.playerC, selectedPlayers.playerD]
            };
            team.totalHandicap = GolfApp.DataModel.calculateTeamHandicap(team);
            GolfApp.DataModel.getTeams().push(team);
            
            // Update the UI
            GolfApp.UIController.displayTeams();
            GolfApp.UIController.displayGroups();
            
            // Remove the overlay
            document.body.removeChild(overlay);
            
            // Enable the tee assignment tab if needed
            if (GolfApp.DataModel.getTeams().length > 0) {
              GolfApp.UIController.getDOMElements().teeAssignmentTabButton.disabled = false;
            }
            
            // Update team selection buttons
            const canFormTeam = GolfApp.DataModel.canFormTeam();
            GolfApp.UIController.getDOMElements().selectTeamBtn.disabled = !canFormTeam;
            GolfApp.UIController.getDOMElements().selectAllBtn.disabled = !canFormTeam;
            GolfApp.UIController.getDOMElements().randomTeamSelectBtn.disabled = !canFormTeam;
            GolfApp.UIController.getDOMElements().sequentialSelectTeamBtn.disabled = !canFormTeam;
            
            return { success: true };
          });
          
          return { success: true };
        }
        
        // Existing function: Sequential Team Assignment
        function sequentialTeamAssignment() {
          // Create overlay for sequential selection
          const overlay = document.createElement('div');
          overlay.className = 'selection-fullscreen';
          overlay.id = 'sequential-assignment-overlay';
          
          const header = document.createElement('h2');
          header.textContent = 'Sequential Team Assignment';
          overlay.appendChild(header);
          
          // Create a table to display current team selections
          const table = document.createElement('table');
          table.id = 'sequential-team-table';
          table.style.width = '80%';
          table.style.margin = '20px auto';
          table.innerHTML = `<tr>
                              <th>Group</th>
                              <th>Selected Player</th>
                              <th>Action</th>
                            </tr>`;
          overlay.appendChild(table);
          
          // Container to list available players for the current group
          const listContainer = document.createElement('div');
          listContainer.id = 'sequential-player-list';
          listContainer.style.margin = '20px auto';
          listContainer.style.width = '80%';
          overlay.appendChild(listContainer);
          
          // Controls for flash effect configuration
          const controlsDiv = document.createElement('div');
          controlsDiv.style.textAlign = 'center';
          controlsDiv.style.marginTop = '20px';
          const flashDurationLabel = document.createElement('label');
          flashDurationLabel.textContent = 'Flash Duration (ms): ';
          const flashDurationInput = document.createElement('input');
          flashDurationInput.type = 'number';
          flashDurationInput.id = 'flashDurationInput';
          flashDurationInput.value = '1500'; // default duration
          flashDurationInput.min = '500';
          flashDurationInput.step = '500';
          flashDurationLabel.appendChild(flashDurationInput);
          
          const closeFlashBtn = document.createElement('button');
          closeFlashBtn.id = 'closeFlashBtn';
          closeFlashBtn.textContent = 'Close Flash';
          closeFlashBtn.style.display = 'none';
          
          controlsDiv.appendChild(flashDurationLabel);
          controlsDiv.appendChild(closeFlashBtn);
          overlay.appendChild(controlsDiv);
          
          document.body.appendChild(overlay);
          
          // Define selection order and state
          const selectionOrder = ['D', 'C', 'B', 'A'];
          let currentIndex = 0;
          const currentTeam = {};
          
          function updateTable() {
            // Clear table except header row
            while (table.rows.length > 1) { table.deleteRow(1); }
            selectionOrder.forEach(group => {
              const row = table.insertRow();
              const cellGroup = row.insertCell();
              cellGroup.textContent = group;
              const cellPlayer = row.insertCell();
              cellPlayer.textContent = currentTeam[group] ? currentTeam[group].name + ' (' + currentTeam[group].displayHandicap + ')' : '';
              const cellAction = row.insertCell();
              if (!currentTeam[group] && selectionOrder[currentIndex] === group) {
                cellAction.textContent = 'Selecting...';
              }
            });
          }
          
          function showPlayersForGroup(group) {
            listContainer.innerHTML = '';
            const players = GolfApp.DataModel.getGroups()[group];
            if (!players || players.length === 0) {
              listContainer.textContent = `No players available in Group ${group}.`;
              return;
            }
            players.forEach((player, index) => {
              const btn = document.createElement('button');
              btn.textContent = player.name + ' (' + player.displayHandicap + ')';
              btn.addEventListener('click', () => selectPlayer(group, index));
              listContainer.appendChild(btn);
            });
          }
          
          let flashTimeout = null;
          
          function selectPlayer(group, playerIndex) {
            const players = GolfApp.DataModel.getGroups()[group];
            if (!players || players.length <= playerIndex) return;
            const selectedPlayer = players[playerIndex];
            // Remove the selected player from the group list
            GolfApp.DataModel.getGroups()[group].splice(playerIndex, 1);
            currentTeam[group] = selectedPlayer;
            updateTable();
            const flashDuration = parseInt(flashDurationInput.value) || 1500;
            // Flash the table row corresponding to the current group
            const rowIndex = selectionOrder.indexOf(group) + 1;
            const row = table.rows[rowIndex];
            row.style.transition = 'background-color 0.5s';
            row.style.backgroundColor = '#ffff99';
            closeFlashBtn.style.display = 'inline-block';
            closeFlashBtn.onclick = () => {
              clearTimeout(flashTimeout);
              row.style.backgroundColor = '';
              closeFlashBtn.style.display = 'none';
              proceedToNextGroup();
            };
            flashTimeout = setTimeout(() => {
              row.style.backgroundColor = '';
              closeFlashBtn.style.display = 'none';
              proceedToNextGroup();
            }, flashDuration);
          }
          
          function proceedToNextGroup() {
            currentIndex++;
            if (currentIndex < selectionOrder.length) {
              const nextGroup = selectionOrder[currentIndex];
              showPlayersForGroup(nextGroup);
              updateTable();
            } else {
              // Complete team formed; add team to DataModel teams
              const teamMembers = selectionOrder.map(group => currentTeam[group]);
              const team = {
                id: GolfApp.DataModel.getTeams().length + 1,
                members: teamMembers
              };
              team.totalHandicap = GolfApp.DataModel.calculateTeamHandicap(team);
              GolfApp.DataModel.getTeams().push(team);
              GolfApp.UIController.displayTeams();
              // Remove overlay to finish the selection process
              document.body.removeChild(overlay);
            }
          }
          
          // Begin with the first group selection
          showPlayersForGroup(selectionOrder[currentIndex]);
          updateTable();
        }
        
        function displayPlayers() {
          const players = GolfApp.DataModel.getPlayers();
          DOMElements.playerList.innerHTML = '';
          players.forEach((player, index) => {
            const playerItem = document.createElement('div');
            playerItem.className = 'player-item';
            playerItem.innerHTML = `
              <div>${player.name}</div>
              <div>
                <span>${player.displayHandicap}</span>
                <button class="remove-btn" data-index="${index}" aria-label="Remove ${player.name}">X</button>
              </div>
            `;
            DOMElements.playerList.appendChild(playerItem);
          });
          document.querySelectorAll('.remove-btn').forEach(btn => {
            btn.addEventListener('click', function() {
              const index = parseInt(this.getAttribute('data-index'));
              GolfApp.DataModel.removePlayer(index);
              displayPlayers();
              if (UIState.isGrouped) { resetGroups(); }
            });
          });
          updatePlayerCount();
        }
        
        function displayGroups() {
          const groups = GolfApp.DataModel.getGroups();
          DOMElements.groupA.innerHTML = '';
          DOMElements.groupB.innerHTML = '';
          DOMElements.groupC.innerHTML = '';
          DOMElements.groupD.innerHTML = '';
          groups.A.forEach(player => {
            const playerItem = document.createElement('div');
            playerItem.className = 'player-item';
            playerItem.innerHTML = `<div>${player.name}</div><div>${player.displayHandicap}</div>`;
            DOMElements.groupA.appendChild(playerItem);
          });
          groups.B.forEach(player => {
            const playerItem = document.createElement('div');
            playerItem.className = 'player-item';
            playerItem.innerHTML = `<div>${player.name}</div><div>${player.displayHandicap}</div>`;
            DOMElements.groupB.appendChild(playerItem);
          });
          groups.C.forEach(player => {
            const playerItem = document.createElement('div');
            playerItem.className = 'player-item';
            playerItem.innerHTML = `<div>${player.name}</div><div>${player.displayHandicap}</div>`;
            DOMElements.groupC.appendChild(playerItem);
          });
          groups.D.forEach(player => {
            const playerItem = document.createElement('div');
            playerItem.className = 'player-item';
            playerItem.innerHTML = `<div>${player.name}</div><div>${player.displayHandicap}</div>`;
            DOMElements.groupD.appendChild(playerItem);
          });
        }
        
        function displayTeams() {
          const teams = GolfApp.DataModel.getTeams();
          DOMElements.teamsContainer.innerHTML = '';
          teams.forEach(team => {
            const teamCard = document.createElement('div');
            teamCard.className = 'team-card';
            const teamHandicap = GolfApp.DataModel.calculateTeamHandicap(team);
            const displayHandicap = teamHandicap.toFixed(
